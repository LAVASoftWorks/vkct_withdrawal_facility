<!DOCTYPE html>
<html lang="en">
<head>
    <title>Piggy Bank Withdrawal</title>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
</head>
<body>

<h1>Withdraw piggy bank funds</h1>

<p>
    NFT address: <input type="text" id="nft_address" value="" style="width: 360px">
</p>
<div id="step1">
    <p>
        NFT metadata URI: <input type="text" id="metadata_uri" value="" style="width: 360px">
    </p>
    <button onclick="getNFTmetadata()">Fetch info</button>
</div>

<div id="step2" style="display: none">
    <div id="tokensList"></div>
    Amount: <input id="amount" type="number" step="any"><br><br>
    Destination: <input type="text" id="dest" disabled value="" style="width: 360px"><br><br>
    <button onclick="withdraw()">Withdraw</button>
</div>

<script>
    function getNFTmetadata()
    {
        let uri = $('#metadata_uri').val().trim();
        if( uri === '' )
        {
            alert('Please paste the NFT metadata URI');
            return;
        }
        
        $.getJSON(uri, function(data) {
            
            if( data.attributes === undefined )
            {
                alert('Invalid data received.');
                return;
            }
            
            let addresses = {};
            for(let i in data.attributes)
            {
                let attr   = data.attributes[i];
                let symbol = attr.trait_type.split(' ')[0];
                addresses[symbol] = attr.value;
            }
            populateTokenDropdown(addresses);
        })
        .fail(function(error) {
            alert(`Error: ${error.status}: ${error.statusText}`);
        });
    }
    
    function parseSplTokenAccountData(data) {
        const mint = new solanaWeb3.PublicKey(data.slice(0, 32));
        const owner = new solanaWeb3.PublicKey(data.slice(32, 64));
        // Amount: bytes 64–71, little-endian
        // Use DataView to read 8 bytes as little-endian unsigned integer (BigUint64)
        const amountBuffer = data.slice(64, 72);
        // Create a DataView; make sure it's an ArrayBuffer
        const amount = new DataView(amountBuffer.buffer, amountBuffer.byteOffset, 8)
        .getBigUint64(0, true); // true = little-endian
        return { mint, owner, amount };
    }
    
    function parseSplTokenMintData(data) {
        // Decimals: byte 44
        const decimals = data[44];
        return { decimals };
    }
    
    async function getSplTokenBalance(symbol, accountAddress) {
        const connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl('devnet'));
        const pubkey = new solanaWeb3.PublicKey(accountAddress);
        const accountInfo = await connection.getAccountInfo(pubkey);
        
        if ( ! accountInfo ) {
            console.log(`Account ${accountAddress} not found!`);
            return;
        }
        const { mint, owner, amount } = parseSplTokenAccountData(accountInfo.data);
        
        // Now fetch mint info to get decimals
        const mintInfo = await connection.getAccountInfo(mint);
        if (!mintInfo) {
            throw new Error("Mint account not found");
        }
        const { decimals } = parseSplTokenMintData(mintInfo.data);
        
        // Human friendly balance
        const displayAmount = Number(amount) / Math.pow(10, decimals);
        const balance       = displayAmount.toString();
        const mintAddr = mint.toBase58();
        
        $(`#tokensList .tokenElement[data-symbol="${symbol}"]`).attr("data-decimals", decimals);
        $(`#tokensList .tokenElement[data-symbol="${symbol}"] input[name="selectedToken"]`).val(mintAddr);
        $(`#tokensList .tokenElement[data-symbol="${symbol}"] .balance`).text(balance);
        
        console.log(`
            Mint: ${mint.toBase58()}
            Owner: ${owner.toBase58()}
            Raw Amount: ${amount.toString()}
            Amount: ${balance}
        `.replace(/ {12}/g, ''));
    }
</script>

<script>
    const Buffer = {
        from: (data) => { return new TextEncoder().encode(data); }
    };
    
    const connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl("devnet"));
    let wallet = null; // Will hold the Phantom wallet public key
    
    const VAULT_PROGRAM_ID = "DrufTFEJCYDvHbLnhbv3kbNLrgFUUvSaK6c23rihC3BH";
    const VAULT_PREFIX_STR = "PoliCromixPiggyBankV2";
    const STD_TOKEN_AGP    = "ATokenGPvbdGVxr1zG9p6g6YXBJz2HkR1z4Z7zS1VvH4"; // Set by Solana
    const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");  // Set by Solana
    
    window.onload = async () => {
        await connectWallet();
    };
    
    async function connectWallet() {
        if (window.solana && window.solana.isPhantom) {
            const response = await window.solana.connect();
            wallet = response.publicKey;
            const addr = wallet.toBase58();
            console.log("Connected to wallet:", addr);
            document.getElementById("dest").value = addr;
        } else {
            alert("Phantom wallet not found");
        }
    }
    
    function populateTokenDropdown(src_addresses) {
        
        const $container = $("#tokensList");
        for(let symbol in src_addresses)
        {
            let addr = src_addresses[symbol];
            let short_addr = addr.substring(0, 4) + '...' + addr.substring(addr.length - 4);
            $container.append(`
                <p>
                    <label class="tokenElement" data-symbol="${symbol}" data-decimals="">
                        <input type="radio" name="selectedToken" value="">
                        ${symbol} [${short_addr}] Balance: <span class="balance">N/A</span>
                    </label>
                </p>
            `);
            getSplTokenBalance(symbol, addr);
        }
        $container.find('input:first').prop('checked', true);
        
        $('#step1').hide();
        $('#step2').show();
        $('#nft_address').prop('readonly', true);
    }
    
    async function withdraw() {
        const $selectedItem = $('input[name="selectedToken"]:checked');
        const selectedMint  = $selectedItem.val();
        const mint          = new solanaWeb3.PublicKey(selectedMint);
        
        const amount = parseFloat(document.getElementById("amount").value);
        if( amount <= 0 )
        {
            alert("Please enter the amount");
            return;
        }
        
        const decimals  = parseInt($selectedItem.closest('label').attr('data-decimals'));
        const bigamount = BigInt(Math.round(amount * (10 ** decimals)));
        
        const NFT_ADDRESS = document.getElementById("nft_address").value;
        if( NFT_ADDRESS === "" )
        {
            alert("Please paste the NFT address");
            return;
        }
        
        
        // Find user's NFT token account for the given mint
        const accounts = await connection.getTokenAccountsByOwner(wallet, {
            mint: mint
        });
        
        if (accounts.value.length === 0) {
            alert("You don't own this NFT");
            return;
        }
        
        const nftAccountPubkey = new solanaWeb3.PublicKey(accounts.value[0].pubkey);
        const WALLET_PUBKEY    = new solanaWeb3.PublicKey(wallet.toBase58());
        
        const [vaultPDA] = solanaWeb3.PublicKey.findProgramAddressSync(
            [Buffer.from(VAULT_PREFIX_STR), mint.toBuffer()],
            new solanaWeb3.PublicKey(VAULT_PROGRAM_ID)
        );
        
        const [ vaultATA ] = solanaWeb3.PublicKey.findProgramAddressSync(
            [
                vaultPDA.toBuffer(),
                TOKEN_PROGRAM_ID.toBuffer(),
                new solanaWeb3.PublicKey(mint).toBuffer(),
            ],
            new solanaWeb3.PublicKey(STD_TOKEN_AGP)
        );
        
        
        const destATA = solanaWeb3.PublicKey.findProgramAddressSync(
            [
                wallet.toBuffer(),
                TOKEN_PROGRAM_ID.toBuffer(),
                new solanaWeb3.PublicKey(mint).toBuffer(),
            ],
            new solanaWeb3.PublicKey(STD_TOKEN_AGP)
        );
        
        const [vaultAuthority] = solanaWeb3.PublicKey.findProgramAddressSync(
            [Buffer.from(VAULT_PREFIX_STR), mint.toBuffer()],
            new solanaWeb3.PublicKey(VAULT_PROGRAM_ID)
        );
        
        // console.log('Buffer.from([1]):', Buffer.from([1]));
        // console.info(destATA);
        
        const dest_pubkey = new solanaWeb3.PublicKey(destATA);
        
        let keys = [
            { pubkey: WALLET_PUBKEY, isSigner: true, isWritable: true },      // signer
            { pubkey: nftAccountPubkey, isSigner: false, isWritable: true },  // nft_account
            { pubkey: mint, isSigner: false, isWritable: false },             // nft_mint
            { pubkey: dest_pubkey, isSigner: false, isWritable: true },       // destination account
            { pubkey: vaultATA, isSigner: false, isWritable: true },          // vault_token_account
            { pubkey: vaultAuthority, isSigner: false, isWritable: false },   // vault_authority
            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }, // token_program
        ];
        
        // keys.forEach((x, i) => {
        //     if (!x.pubkey || typeof x.pubkey.toBase58 !== "function") {
        //         console.error(`❌ Invalid pubkey at index ${i}:`, x);
        //     } else {
        //         console.log(`✅ Key ${i}:`, x.pubkey.toBase58());
        //     }
        // });
        
        const data = await buildWithdrawData(bigamount);
        
        console.log("Withdraw IX first 8 bytes (discriminator):", Array.from(data.slice(0, 8)));
        
        const ix   = new solanaWeb3.TransactionInstruction({
            keys: keys,
            programId: new solanaWeb3.PublicKey(VAULT_PROGRAM_ID),
            data: Buffer.from(data)
        });
        
        // console.log('TransactionInstruction:', ix);
        
        const tx = new solanaWeb3.Transaction().add(ix);
        tx.feePayer = wallet;
        tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        
        const signedTx = await window.solana.signTransaction(tx);
        
        const simulation = await connection.simulateTransaction(tx);
        console.log("Simulation result:", simulation);
        return;
        
        let sig;
        try {
            sig = await connection.sendRawTransaction(signedTx.serialize());
            console.log("Transaction sent:", sig);
        } catch (e) {
            // @solana/web3.js v1.86.0+ includes logs property
            if (e.logs) {
                console.error("Transaction failed with logs:");
                for (let line of e.logs) console.error(line);
            }
            console.error("SendTransactionError:", e);
            return;
        }
        
        await connection.confirmTransaction(sig, 'confirmed');
        alert(`Transaction sent: ${sig}`);
    }
    
    function buildWithdrawData(amount) {
        // Use the discriminator from your IDL
        const discriminator = Uint8Array.from([183, 18, 70, 156, 148, 109, 161, 34]);
        // Amount as u64 little-endian
        const amountBuffer = new ArrayBuffer(8);
        const view = new DataView(amountBuffer);
        view.setBigUint64(0, BigInt(amount), true); // true = little-endian
        
        // Concatenate discriminator and amount
        const data = new Uint8Array(16);
        data.set(discriminator, 0);
        data.set(new Uint8Array(amountBuffer), 8);
        return data;
    }
</script>

</body>
</html>
